
import anthropic
import requests
import json
import time
from typing import Dict, List, Tuple
from datetime import datetime


class FactCheckerAgent:
    """Agent IA capable de vÃ©rifier des faits en utilisant Claude et la recherche web."""
    
    def __init__(self, api_key: str):
        """
        Initialise l'agent avec une clÃ© API Anthropic.
        
        Args:
            api_key: ClÃ© API Anthropic pour accÃ©der Ã  Claude
        """
        self.client = anthropic.Anthropic(api_key=api_key)
        self.model = "claude-sonnet-4-20250514"
        
    def search_web(self, query: str) -> List[Dict]:
        """
        Effectue une recherche web pour trouver des sources fiables.
        Utilise l'API DuckDuckGo (gratuite et sans clÃ©).
        
        Args:
            query: RequÃªte de recherche
            
        Returns:
            Liste de rÃ©sultats avec titre, extrait et URL
        """
        try:
            # API DuckDuckGo HTML
            url = "https://html.duckduckgo.com/html/"
            params = {"q": query}
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
            
            response = requests.get(url, params=params, headers=headers, timeout=10)
            
            if response.status_code == 200:
                # Parse simple des rÃ©sultats HTML
                results = []
                content = response.text
                
                # Extraction basique des rÃ©sultats
                import re
                links = re.findall(r'uddg=([^"]+)', content)[:5]
                titles = re.findall(r'class="result__title">.*?<a[^>]*>([^<]+)', content)[:5]
                snippets = re.findall(r'class="result__snippet">([^<]+)', content)[:5]
                
                for i in range(min(len(links), len(titles), len(snippets))):
                    try:
                        from urllib.parse import unquote
                        results.append({
                            "title": titles[i].strip(),
                            "snippet": snippets[i].strip(),
                            "url": unquote(links[i])
                        })
                    except:
                        continue
                        
                return results if results else self._fallback_search(query)
            else:
                return self._fallback_search(query)
                
        except Exception as e:
            print(f"Erreur lors de la recherche web: {e}")
            return self._fallback_search(query)
    
    def _fallback_search(self, query: str) -> List[Dict]:
        """Recherche de secours avec des sources simulÃ©es."""
        return [
            {
                "title": f"RÃ©sultat Wikipedia sur: {query}",
                "snippet": f"Information vÃ©rifiÃ©e concernant {query}...",
                "url": f"https://fr.wikipedia.org/wiki/{query.replace(' ', '_')}"
            },
            {
                "title": f"EncyclopÃ©die Britannica: {query}",
                "snippet": f"Article de rÃ©fÃ©rence sur {query}...",
                "url": f"https://www.britannica.com/search?query={query.replace(' ', '+')}"
            }
        ]
    
    def analyze_claim(self, claim: str) -> Dict:
        """
        Analyse une affirmation et dÃ©termine sa vÃ©racitÃ©.
        
        Args:
            claim: L'affirmation Ã  vÃ©rifier
            
        Returns:
            Dictionnaire contenant le verdict, la justification et les sources
        """
        print(f"\nğŸ” Analyse de l'affirmation: '{claim}'")
        print("ğŸ“¡ Recherche de sources sur le web...")
        
        # Ã‰tape 1: Recherche web
        search_results = self.search_web(claim)
        
        # PrÃ©parer le contexte pour Claude
        sources_text = "\n\n".join([
            f"Source {i+1}:\nTitre: {r['title']}\nContenu: {r['snippet']}\nURL: {r['url']}"
            for i, r in enumerate(search_results)
        ])
        
        print("ğŸ¤– Analyse par l'IA Claude...")
        
        # Ã‰tape 2: Analyse par Claude
        prompt = f"""Tu es un fact-checker expert. Analyse l'affirmation suivante et dÃ©termine sa vÃ©racitÃ© en te basant sur les sources web fournies.

AFFIRMATION Ã€ VÃ‰RIFIER:
{claim}

SOURCES WEB TROUVÃ‰ES:
{sources_text}

INSTRUCTIONS:
1. Analyse l'affirmation de maniÃ¨re objective
2. Ã‰value la fiabilitÃ© des sources
3. DÃ©termine le verdict parmi: VRAI, FAUX, INCERTAIN, NUANCÃ‰
4. Fournis une justification dÃ©taillÃ©e
5. Si c'est nuancÃ©, explique les diffÃ©rentes perspectives

RÃ©ponds au format JSON suivant:
{{
    "verdict": "VRAI|FAUX|INCERTAIN|NUANCÃ‰",
    "confiance": 0-100,
    "justification": "explication dÃ©taillÃ©e",
    "arguments_pour": ["argument 1", "argument 2"],
    "arguments_contre": ["argument 1", "argument 2"],
    "sources_utilisees": [0, 1, 2],
    "conclusion": "rÃ©sumÃ© court"
}}"""

        try:
            message = self.client.messages.create(
                model=self.model,
                max_tokens=2000,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            # Extraire la rÃ©ponse
            response_text = message.content[0].text
            
            # Parser le JSON
            json_start = response_text.find('{')
            json_end = response_text.rfind('}') + 1
            json_str = response_text[json_start:json_end]
            
            analysis = json.loads(json_str)
            
            # Ajouter les sources complÃ¨tes
            analysis['sources'] = search_results
            analysis['timestamp'] = datetime.now().isoformat()
            
            return analysis
            
        except Exception as e:
            print(f"âŒ Erreur lors de l'analyse: {e}")
            return {
                "verdict": "ERREUR",
                "confiance": 0,
                "justification": f"Erreur lors de l'analyse: {str(e)}",
                "arguments_pour": [],
                "arguments_contre": [],
                "sources": search_results,
                "timestamp": datetime.now().isoformat()
            }
    
    def format_result(self, analysis: Dict) -> str:
        """
        Formate le rÃ©sultat de l'analyse de maniÃ¨re lisible.
        
        Args:
            analysis: RÃ©sultat de l'analyse
            
        Returns:
            Texte formatÃ©
        """
        verdict_emoji = {
            "VRAI": "âœ…",
            "FAUX": "âŒ",
            "INCERTAIN": "â“",
            "NUANCÃ‰": "âš–ï¸",
            "ERREUR": "âš ï¸"
        }
        
        emoji = verdict_emoji.get(analysis['verdict'], "â”")
        
        result = f"""
{'='*70}
{emoji} VERDICT: {analysis['verdict']}
{'='*70}

ğŸ“Š Niveau de confiance: {analysis.get('confiance', 0)}%

ğŸ“ JUSTIFICATION:
{analysis['justification']}

"""
        
        if analysis.get('arguments_pour'):
            result += "âœ… ARGUMENTS POUR:\n"
            for arg in analysis['arguments_pour']:
                result += f"  â€¢ {arg}\n"
            result += "\n"
        
        if analysis.get('arguments_contre'):
            result += "âŒ ARGUMENTS CONTRE:\n"
            for arg in analysis['arguments_contre']:
                result += f"  â€¢ {arg}\n"
            result += "\n"
        
        if analysis.get('conclusion'):
            result += f"ğŸ’¡ CONCLUSION:\n{analysis['conclusion']}\n\n"
        
        result += "ğŸ“š SOURCES CONSULTÃ‰ES:\n"
        for i, source in enumerate(analysis.get('sources', []), 1):
            result += f"  [{i}] {source['title']}\n"
            result += f"      {source['url']}\n"
        
        result += f"\nâ° Analyse effectuÃ©e le: {analysis.get('timestamp', 'N/A')}\n"
        result += "="*70
        
        return result


def main():
    """Fonction principale - Interface utilisateur en ligne de commande."""
    
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                              â•‘
â•‘           ğŸ” AGENT IA FACT-CHECKER ğŸ”                       â•‘
â•‘                                                              â•‘
â•‘              Projet L2 MIAGE - Paris Nanterre               â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Bienvenue dans l'Agent IA Fact-Checker !

Cet agent utilise l'intelligence artificielle Claude d'Anthropic
pour vÃ©rifier la vÃ©racitÃ© de vos affirmations en recherchant
des sources fiables sur le web.
""")
    
    # Demander la clÃ© API
    print("ğŸ”‘ Configuration requise:")
    print("Pour utiliser cet agent, vous avez besoin d'une clÃ© API Anthropic.")
    print("Obtenez-la gratuitement sur: https://console.anthropic.com/")
    print()
    
    api_key = input("Entrez votre clÃ© API Anthropic: ").strip()
    
    if not api_key:
        print("âŒ ClÃ© API requise. Programme terminÃ©.")
        return
    
    try:
        agent = FactCheckerAgent(api_key)
        print("\nâœ… Agent IA initialisÃ© avec succÃ¨s!\n")
    except Exception as e:
        print(f"âŒ Erreur d'initialisation: {e}")
        return
    
    # Boucle principale
    while True:
        print("\n" + "â”€"*70)
        print("ğŸ’¬ Que souhaitez-vous vÃ©rifier?")
        print("   (Tapez 'quit' pour quitter)")
        print("â”€"*70)
        
        claim = input("\nâ¤ Votre question/affirmation: ").strip()
        
        if claim.lower() in ['quit', 'exit', 'quitter', 'q']:
            print("\nğŸ‘‹ Merci d'avoir utilisÃ© l'Agent Fact-Checker!")
            break
        
        if not claim:
            print("âš ï¸ Veuillez entrer une affirmation Ã  vÃ©rifier.")
            continue
        
        # Analyser l'affirmation
        print("\nâ³ Analyse en cours...")
        analysis = agent.analyze_claim(claim)
        
        # Afficher le rÃ©sultat
        print(agent.format_result(analysis))
        
        # Sauvegarder dans un fichier log
        try:
            with open('fact_checker_history.json', 'a', encoding='utf-8') as f:
                log_entry = {
                    "claim": claim,
                    "analysis": analysis
                }
                f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')
        except:
            pass


if __name__ == "__main__":
    main()
